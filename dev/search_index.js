var documenterSearchIndex = {"docs":
[{"location":"nnmm/Part1_introduction/#Part-1:-Introduction-to-NNMM","page":"Part 1. Introduction","title":"Part 1: Introduction to NNMM","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"nnmm/Part1_introduction/#1.-Overview","page":"Part 1. Introduction","title":"1. Overview","text":"The Mixed Effect Neural Networks (NN-MM) extend linear mixed models (\"MM\") to multilayer neural networks (\"NN\") by adding one middle layer between the genotype layer and phenotypes layer. Nodes in the middle layer represent intermediate traits, e.g., the known intermediate omics features such as gene expression levels can be incorporated in the middle layer. These three sequential layers form a unified network.\n\n(Image: )\n\nNN-MM allows any patterns of missing data in the middle layer, and missing data will be sampled. In the figure above, for an individual, the gene expression levels of the first two genes are 0.9 and 0.1, respectively, and the gene expression level of the last gene is missing to be sampled. The missing patterns of gene expression levels can be different for different individuals.","category":"section"},{"location":"nnmm/Part1_introduction/#2.-Extend-Linear-Mixed-Model-to-Multilayer-Neural-Networks","page":"Part 1. Introduction","title":"2. Extend Linear Mixed Model to Multilayer Neural Networks","text":"Multiple independent single-trait mixed models are used to model the relationships between the input layer (genotypes) and middle layer (intermediate traits). Activation functions in the neural network are used to approximate the linear/nonlinear relationships between the middle layer (intermediate traits) and output layer (phenotypes). Missing values in the middle layer (intermediate traits) are sampled by Hamiltonian Monte Carlo based on the upstream genotype layer and downstream phenotype layer.","category":"section"},{"location":"nnmm/Part1_introduction/#Architecture-Summary","page":"Part 1. Introduction","title":"Architecture Summary","text":"┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│  Genotypes  │ ──► │   Omics     │ ──► │ Phenotypes  │\n│  (Layer 1)  │     │  (Layer 2)  │     │  (Layer 3)  │\n└─────────────┘     └─────────────┘     └─────────────┘\n     SNPs           Gene Expression        Traits\n                    Metabolomics\n                    (can be missing)","category":"section"},{"location":"nnmm/Part1_introduction/#Key-Components","page":"Part 1. Introduction","title":"Key Components","text":"Component Description\nLayer 1→2 Bayesian regression (BayesA, BayesB, BayesC, etc.)\nLayer 2→3 Activation function (linear, sigmoid, tanh, etc.)\nMissing omics Sampled via Hamiltonian Monte Carlo\n\nDetails can be found in our publications:\n\nTianjing Zhao, Jian Zeng, and Hao Cheng. Extend mixed models to multilayer neural networks for genomic prediction including intermediate omics data, GENETICS, 2022; https://doi.org/10.1093/genetics/iyac034.\nTianjing Zhao, Rohan Fernando, and Hao Cheng. Interpretable artificial neural networks incorporating Bayesian alphabet models for genome-wide prediction and association studies, G3 Genes|Genomes|Genetics, 2021; https://doi.org/10.1093/g3journal/jkab228","category":"section"},{"location":"nnmm/Part1_introduction/#3.-Flexibility","page":"Part 1. Introduction","title":"3. Flexibility","text":"NN-MM can fit fully-connected neural networks ((a),(b)), or partial-connected neural networks ((c),(d)). Also, the relationship between middle layer (intermediate traits) and output layer (phenotypes) can be based on activation functions ((a),(c)), or pre-defined by a user-defined function ((b),(d)).\n\n(Image: )","category":"section"},{"location":"nnmm/Part1_introduction/#Network-Types","page":"Part 1. Introduction","title":"Network Types","text":"Type Description Use Case\n(a) Fully-connected + Activation All SNPs predict all omics; standard activation General prediction\n(b) Fully-connected + User-defined All SNPs predict all omics; custom function Domain-specific models\n(c) Partial-connected + Activation SNP groups predict specific omics; standard activation Pathway analysis\n(d) Partial-connected + User-defined SNP groups predict specific omics; custom function Advanced modeling","category":"section"},{"location":"nnmm/Part1_introduction/#4.-Multi-threaded-Parallelism","page":"Part 1. Introduction","title":"4. Multi-threaded Parallelism","text":"By default, multiple single-trait models will be used to model the relationships between input layer (genotypes) and middle layer (intermediate traits). Multi-threaded parallelism will be used for parallel computing. The number of threads can be checked by running Threads.nthreads() in Julia. Usually, using multiple threads will be about 3 times faster than using a single thread.\n\nThe number of execution threads is controlled by using the -t/--threads command-line argument (requires at least Julia 1.5).\n\nFor example, to start Julia with 4 threads:\n\njulia --threads 4\n\nOr set the environment variable before starting Julia:\n\nexport JULIA_NUM_THREADS=4\njulia\n\nIf you're using Juno via IDE like Atom, or VS Code with the Julia extension, multiple threads are typically loaded automatically based on system settings.","category":"section"},{"location":"nnmm/Part1_introduction/#5.-Quick-Start","page":"Part 1. Introduction","title":"5. Quick Start","text":"See the Tutorial for a complete walkthrough, or the Quick Start for a minimal example.","category":"section"},{"location":"nnmm/Part1_introduction/#Minimal-Example","page":"Part 1. Introduction","title":"Minimal Example","text":"using NNMM\nusing NNMM.Datasets\nusing DataFrames, CSV\nusing Random\n\nRandom.seed!(42)\n\n# Load example data\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Create data files\nomics_df = pheno_df[:, vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])]\nCSV.write(\"omics.csv\", omics_df; missingstring=\"NA\")\nCSV.write(\"trait.csv\", pheno_df[:, [:ID, :trait1]]; missingstring=\"NA\")\n\n# Define model\nlayers = [\n    Layer(layer_name=\"geno\", data_path=[geno_path]),\n    Layer(layer_name=\"omics\", data_path=\"omics.csv\", missing_value=\"NA\"),\n    Layer(layer_name=\"pheno\", data_path=\"trait.csv\", missing_value=\"NA\")\n]\n\nequations = [\n    Equation(from_layer_name=\"geno\", to_layer_name=\"omics\",\n             equation=\"omics = intercept + geno\",\n             omics_name=[\"omic$i\" for i in 1:10], method=\"BayesC\"),\n    Equation(from_layer_name=\"omics\", to_layer_name=\"pheno\",\n             equation=\"pheno = intercept + omics\",\n             phenotype_name=[\"trait1\"], activation_function=\"linear\")\n]\n\n# Run MCMC\nresults = runNNMM(layers, equations; chain_length=5000, burnin=1000)\n\n# Cleanup\nrm(\"omics.csv\", force=true)\nrm(\"trait.csv\", force=true)","category":"section"},{"location":"nnmm/Part1_introduction/#6.-Tutorial-Overview","page":"Part 1. Introduction","title":"6. Tutorial Overview","text":"Part Topic Description\nPart 2 Basic NNMM Fully-connected network with latent traits\nPart 3 NNMM with Omics Incorporating observed omics data\nPart 4 Partial Networks SNP groups → specific omics\nPart 5 Custom Functions User-defined activation functions\nPart 6 Traditional GP BayesC as NNMM special case","category":"section"},{"location":"manual/getstarted/#Get-Started","page":"Get Started","title":"Get Started","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"manual/getstarted/#Installation","page":"Get Started","title":"Installation","text":"To install Julia, please go to the official Julia website. Please see platform specific instructions if you have trouble installing Julia.\n\nRequirements: Julia 1.9 or later.\n\nTo install the NNMM package, use the following command inside the Julia REPL (or IJulia Notebook):\n\nusing Pkg\nPkg.add(\"NNMM\")\n\nTo load the NNMM package:\n\nusing NNMM","category":"section"},{"location":"manual/getstarted/#Development-Version","page":"Get Started","title":"Development Version","text":"To use the latest/beta features under development:\n\nPkg.add(url=\"https://github.com/reworkhow/NNMM.jl\")","category":"section"},{"location":"manual/getstarted/#Jupyter-Notebook","page":"Get Started","title":"Jupyter Notebook","text":"If you prefer \"reproducible research\", an interactive Jupyter Notebook interface is available for Julia (and therefore NNMM). The Jupyter Notebook is an open-source web application for creating and sharing documents that contain live code, equations, visualizations and explanatory text. To install IJulia for Jupyter Notebook, please go to IJulia.","category":"section"},{"location":"manual/getstarted/#Multi-threaded-Parallelism","page":"Get Started","title":"Multi-threaded Parallelism","text":"NNMM supports multi-threaded parallelism for faster computation. The number of threads can be checked by:\n\nThreads.nthreads()\n\nTo start Julia with multiple threads (requires Julia 1.5+):\n\njulia --threads 4\n\nOr set the environment variable:\n\nexport JULIA_NUM_THREADS=4\njulia","category":"section"},{"location":"manual/getstarted/#Access-Documentation","page":"Get Started","title":"Access Documentation","text":"warning: Warning\nPlease load the NNMM package first.\n\nTo show basic information about NNMM in REPL or IJulia notebook, use ?NNMM and press enter.\n\nFor help on a specific function, type ? followed by its name:\n\n?runNNMM   # Help on runNNMM function\n?Layer     # Help on Layer type\n?Equation  # Help on Equation type\n\nThe full documentation is available here.","category":"section"},{"location":"manual/getstarted/#Quick-Example","page":"Get Started","title":"Quick Example","text":"using NNMM\nusing NNMM.Datasets\nusing DataFrames, CSV\nusing Random\n\n# Set seed for reproducibility\nRandom.seed!(42)\n\n# Load built-in example data\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Create omics and trait files\nomics_df = pheno_df[:, vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])]\nCSV.write(\"omics.csv\", omics_df; missingstring=\"NA\")\nCSV.write(\"trait.csv\", pheno_df[:, [:ID, :trait1]]; missingstring=\"NA\")\n\n# Define model architecture\nlayers = [\n    Layer(layer_name=\"geno\", data_path=[geno_path]),\n    Layer(layer_name=\"omics\", data_path=\"omics.csv\", missing_value=\"NA\"),\n    Layer(layer_name=\"pheno\", data_path=\"trait.csv\", missing_value=\"NA\")\n]\n\nequations = [\n    Equation(\n        from_layer_name=\"geno\", to_layer_name=\"omics\",\n        equation=\"omics = intercept + geno\",\n        omics_name=[\"omic$i\" for i in 1:10],\n        method=\"BayesC\"\n    ),\n    Equation(\n        from_layer_name=\"omics\", to_layer_name=\"pheno\",\n        equation=\"pheno = intercept + omics\",\n        phenotype_name=[\"trait1\"],\n        activation_function=\"linear\"\n    )\n]\n\n# Run MCMC analysis\nresults = runNNMM(layers, equations;\n    chain_length=5000,\n    burnin=1000,\n    output_folder=\"my_results\"\n)\n\n# Access EBV results\nebv = results[\"EBV_NonLinear\"]\nprintln(\"Mean EBV: \", mean(ebv.EBV))\n\n# Cleanup\nrm(\"omics.csv\", force=true)\nrm(\"trait.csv\", force=true)","category":"section"},{"location":"manual/getstarted/#Run-Your-Analysis","page":"Get Started","title":"Run Your Analysis","text":"There are several ways to run your analysis:","category":"section"},{"location":"manual/getstarted/#Interactive-Session-(REPL)","page":"Get Started","title":"Interactive Session (REPL)","text":"Start an interactive session by double-clicking the Julia executable or running julia from the command line:\n\njulia> using NNMM\njulia> # your analysis code here\n\nTo evaluate code written in a file script.jl in REPL:\n\njulia> include(\"script.jl\")\n\nTo exit the interactive session, type ^D (control + d) or quit().","category":"section"},{"location":"manual/getstarted/#Command-Line","page":"Get Started","title":"Command Line","text":"To run code in a file non-interactively from the command line:\n\njulia script.jl\n\nIf you want to pass arguments to your script:\n\njulia script.jl arg1 arg2\n\nwhere arguments arg1 and arg2 are passed as ARGS[1] and ARGS[2] of type String.","category":"section"},{"location":"manual/getstarted/#Jupyter-Notebook-2","page":"Get Started","title":"Jupyter Notebook","text":"To run code in Jupyter Notebook, please see IJulia.","category":"section"},{"location":"manual/getstarted/#Key-Concepts","page":"Get Started","title":"Key Concepts","text":"","category":"section"},{"location":"manual/getstarted/#Three-Layer-Architecture","page":"Get Started","title":"Three-Layer Architecture","text":"NNMM uses a three-layer neural network:\n\nLayer 1 (Input): Genotypes (SNP markers)\nLayer 2 (Hidden): Omics/Latent traits (can have missing values)\nLayer 3 (Output): Phenotypes","category":"section"},{"location":"manual/getstarted/#Core-Types","page":"Get Started","title":"Core Types","text":"Type Purpose\nLayer Defines a layer with data file, layer name, and options\nEquation Connects two layers with a model equation and Bayesian method","category":"section"},{"location":"manual/getstarted/#Core-Function","page":"Get Started","title":"Core Function","text":"Function Purpose\nrunNNMM(layers, equations; ...) Run the NNMM analysis","category":"section"},{"location":"manual/getstarted/#Next-Steps","page":"Get Started","title":"Next Steps","text":"Tutorial: Complete step-by-step analysis\nPart 2: Basic NNMM: Fully-connected networks\nPart 3: NNMM with Omics: Using observed omics data\nAPI Reference: Full function documentation","category":"section"},{"location":"nnmm/Part2_NNMM/#Part-2:-Mixed-Effect-Neural-Network-(NNMM)","page":"Part 2. NNMM","title":"Part 2: Mixed Effect Neural Network (NNMM)","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"nnmm/Part2_NNMM/#Model-Architecture","page":"Part 2. NNMM","title":"Model Architecture","text":"NNMM extends traditional genomic prediction by adding an intermediate layer:\n\nGenotypes → Unobserved Intermediate Traits → Phenotypes\n (Layer 1)         (Layer 2)                 (Layer 3)\n\nWhen the intermediate traits are unobserved (latent), they are sampled via Hamiltonian Monte Carlo (HMC).\n\ntip: Data Preparation\nIt is recommended to center the phenotypes to have zero mean before running NNMM.\n\nimportant: Data Requirements\nGenotype and phenotype files must have matching individual IDs. This example uses the  simulated_omics_data dataset which has 3534 aligned individuals.","category":"section"},{"location":"nnmm/Part2_NNMM/#Example:-Fully-Connected-Neural-Network-with-Unobserved-Latent-Traits","page":"Part 2. NNMM","title":"Example: Fully-Connected Neural Network with Unobserved Latent Traits","text":"This example demonstrates:\n\nActivation function: tanh (other options: \"sigmoid\", \"relu\", \"leakyrelu\", \"linear\")\nNumber of latent nodes: 3 (unobserved intermediate traits)\nBayesian model: BayesC (multiple independent single-trait models for marker effects)\nLatent trait sampling: Hamiltonian Monte Carlo\n\n(Image: )\n\n# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Read data (using simulated_omics_data with aligned individuals)\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\n# Read phenotypes (output layer)\nphenotypes = CSV.read(pheno_path, DataFrame)\n\n# Step 3: Create latent trait file (all values missing)\n# When no omics data is observed, create a file with all missing values\n# NNMM will sample these latent traits via HMC\nn_individuals = nrow(phenotypes)\nn_latent = 3  # Number of latent nodes in middle layer\n\nlatent_df = DataFrame(ID = phenotypes.ID)\nfor i in 1:n_latent\n    latent_df[!, Symbol(\"latent$i\")] = fill(missing, n_individuals)\nend\n\n# Write to file with \"NA\" as missing string\nlatent_file = \"latent_traits.csv\"\nCSV.write(latent_file, latent_df; missingstring=\"NA\")\n\n# Step 4: Create phenotype file for Layer 3\n# Center phenotype for better convergence\npheno_mean = mean(skipmissing(phenotypes.trait1))\nphenotypes.trait1_centered = phenotypes.trait1 .- pheno_mean\n\ntrait_file = \"phenotypes_layer3.csv\"\ntrait_df = phenotypes[:, [:ID, :trait1_centered]]\nrename!(trait_df, :trait1_centered => :y1)\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\n# Step 5: Define layers\nlayers = [\n    # Layer 1: Genotypes (input layer)\n    Layer(\n        layer_name = \"genotypes\",\n        data_path = [geno_path]\n    ),\n    # Layer 2: Latent traits (all missing, will be sampled via HMC)\n    Layer(\n        layer_name = \"latent\",\n        data_path = latent_file,\n        missing_value = \"NA\"\n    ),\n    # Layer 3: Phenotypes (output layer)\n    Layer(\n        layer_name = \"phenotypes\",\n        data_path = trait_file,\n        missing_value = \"NA\"\n    )\n]\n\n# Step 6: Define equations\nequations = [\n    # Genotypes → Latent traits (BayesC)\n    Equation(\n        from_layer_name = \"genotypes\",\n        to_layer_name = \"latent\",\n        equation = \"latent = intercept + genotypes\",\n        omics_name = [\"latent1\", \"latent2\", \"latent3\"],  # Names match CSV columns\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    # Latent traits → Phenotypes (with tanh activation)\n    Equation(\n        from_layer_name = \"latent\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + latent\",\n        phenotype_name = [\"y1\"],\n        method = \"BayesC\",\n        activation_function = \"tanh\"  # Nonlinear relationship\n    )\n]\n\n# Step 7: Run analysis\nout = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    output_folder = \"nnmm_latent_results\"\n)\n\n# Step 8: Check accuracy (simulated data has true breeding values)\nebv = out[\"EBV_NonLinear\"]\n\n# Convert to proper types and merge\nebv.ID = string.(ebv.ID)\nphenotypes.ID = string.(phenotypes.ID)\nresults = innerjoin(ebv, phenotypes[:, [:ID, :genetic_total]], on=:ID)\naccuracy = cor(Float64.(results.EBV), results.genetic_total)\nprintln(\"Prediction accuracy: \", round(accuracy, digits=4))\n\n# Cleanup temporary files\nrm(latent_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part2_NNMM/#Output-Files","page":"Part 2. NNMM","title":"Output Files","text":"When latent traits are named \"latent1\", \"latent2\", \"latent3\", the output files use these names directly.","category":"section"},{"location":"nnmm/Part2_NNMM/#Estimate-Files-(Posterior-Means)","page":"Part 2. NNMM","title":"Estimate Files (Posterior Means)","text":"File Name Description\nEBV_NonLinear.txt Estimated breeding values for observed phenotype\nEBV_latent1.txt EBV for latent node 1\nEBV_latent2.txt EBV for latent node 2\nEBV_latent3.txt EBV for latent node 3\ngenetic_variance.txt Genetic variance-covariance of all latent nodes\nheritability.txt Heritability estimates for all latent nodes\nlocation_parameters.txt Intercept estimates for all latent nodes\nneural_networks_bias_and_weights.txt Bias and weights between latent nodes and phenotypes\npi_genotypes.txt Marker inclusion probability (π) for all latent nodes\nmarker_effects_genotypes.txt Marker effects for all latent nodes\nresidual_variance.txt Residual variance-covariance for all latent nodes","category":"section"},{"location":"nnmm/Part2_NNMM/#MCMC-Sample-Files","page":"Part 2. NNMM","title":"MCMC Sample Files","text":"File Name Description\nMCMC_samples_EBV_NonLinear.txt MCMC samples for phenotype breeding values\nMCMC_samples_EBV_latent1.txt MCMC samples for latent node 1 EBV\nMCMC_samples_EBV_latent2.txt MCMC samples for latent node 2 EBV\nMCMC_samples_EBV_latent3.txt MCMC samples for latent node 3 EBV\nMCMC_samples_genetic_variance.txt MCMC samples for genetic variance-covariance\nMCMC_samples_heritability.txt MCMC samples for heritability\nMCMC_samples_marker_effects_genotypes_latent1.txt Marker effect samples for latent node 1\nMCMC_samples_marker_effects_genotypes_latent2.txt Marker effect samples for latent node 2\nMCMC_samples_marker_effects_genotypes_latent3.txt Marker effect samples for latent node 3\nMCMC_samples_marker_effects_variances_genotypes.txt Marker effect variance samples\nMCMC_samples_neural_networks_bias_and_weights.txt Neural network parameter samples\nMCMC_samples_pi_genotypes.txt π samples for all latent nodes\nMCMC_samples_residual_variance.txt Residual variance samples","category":"section"},{"location":"nnmm/Part2_NNMM/#Different-Number-of-Latent-Nodes","page":"Part 2. NNMM","title":"Different Number of Latent Nodes","text":"The number of latent nodes is determined by the omics_name parameter in the first equation:\n\n# For 5 latent nodes:\nomics_name = [\"latent1\", \"latent2\", \"latent3\", \"latent4\", \"latent5\"]\n\n# For 10 latent nodes:\nomics_name = [\"latent$i\" for i in 1:10]","category":"section"},{"location":"nnmm/Part2_NNMM/#Different-Activation-Functions","page":"Part 2. NNMM","title":"Different Activation Functions","text":"# Linear (traditional regression)\nEquation(..., activation_function = \"linear\")\n\n# Sigmoid (outputs between 0 and 1)\nEquation(..., activation_function = \"sigmoid\")\n\n# Tanh (outputs between -1 and 1)\nEquation(..., activation_function = \"tanh\")\n\n# ReLU (sparse activation)\nEquation(..., activation_function = \"relu\")\n\n# Leaky ReLU (sparse with gradient flow)\nEquation(..., activation_function = \"leakyrelu\")","category":"section"},{"location":"nnmm/Part2_NNMM/#Tips-for-Best-Results","page":"Part 2. NNMM","title":"Tips for Best Results","text":"Center phenotypes: Subtract the mean from phenotypes before running NNMM.\nChoose number of latent nodes: More nodes capture more variance but increase computational cost. Start with 3-5 nodes.\nChain length: For production, use chain_length=50000 or more. For testing, chain_length=1000 is sufficient.\nConvergence: Check MCMC samples for convergence. If variance estimates are unstable, increase chain length.\nActivation function: Use \"linear\" for simple additive models, \"tanh\" or \"sigmoid\" for nonlinear relationships.","category":"section"},{"location":"manual/public/#Public-API-Reference","page":"Public Functions","title":"Public API Reference","text":"Documentation for NNMM.jl's public interface. Below are functions available to general users.\n\nnote: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"manual/public/#Index","page":"Public Functions","title":"Index","text":"Pages = [\"public.md\"]\nModules = [NNMM]","category":"section"},{"location":"manual/public/#Core-Types","page":"Public Functions","title":"Core Types","text":"","category":"section"},{"location":"manual/public/#Layer","page":"Public Functions","title":"Layer","text":"Defines a layer in the neural network architecture.\n\nUsage:\n\n# Genotype layer (input) - note the [] around the path\nlayer1 = Layer(layer_name=\"geno\", data_path=[\"genotypes.csv\"])\n\n# Omics layer (hidden) with missing value handling\nlayer2 = Layer(layer_name=\"omics\", data_path=\"omics.csv\", missing_value=\"NA\")\n\n# Phenotype layer (output)\nlayer3 = Layer(layer_name=\"pheno\", data_path=\"phenotypes.csv\", missing_value=\"NA\")","category":"section"},{"location":"manual/public/#Equation","page":"Public Functions","title":"Equation","text":"Defines the statistical model connecting two layers.\n\nUsage:\n\n# Genotypes → Omics (BayesC with 10 omics features)\neq1 = Equation(\n    from_layer_name = \"geno\",\n    to_layer_name = \"omics\", \n    equation = \"omics = intercept + geno\",\n    omics_name = [\"omic1\", \"omic2\", \"omic3\"],\n    method = \"BayesC\",\n    estimatePi = true\n)\n\n# Omics → Phenotypes (with sigmoid activation)\neq2 = Equation(\n    from_layer_name = \"omics\",\n    to_layer_name = \"pheno\",\n    equation = \"pheno = intercept + omics\",\n    phenotype_name = [\"y1\"],\n    method = \"BayesC\",\n    activation_function = \"sigmoid\"\n)","category":"section"},{"location":"manual/public/#Supporting-Types","page":"Public Functions","title":"Supporting Types","text":"","category":"section"},{"location":"manual/public/#Main-Functions","page":"Public Functions","title":"Main Functions","text":"","category":"section"},{"location":"manual/public/#runNNMM","page":"Public Functions","title":"runNNMM","text":"The primary function for running NNMM analysis.\n\nUsage:\n\nresults = runNNMM(layers, equations;\n    chain_length = 10000,\n    burnin = 2000,\n    output_folder = \"my_results\",\n    seed = 42\n)","category":"section"},{"location":"manual/public/#describe","page":"Public Functions","title":"describe","text":"Print model summary information.","category":"section"},{"location":"manual/public/#Data-Reading-Functions","page":"Public Functions","title":"Data Reading Functions","text":"","category":"section"},{"location":"manual/public/#read_phenotypes","page":"Public Functions","title":"read_phenotypes","text":"Read phenotype data from a file.","category":"section"},{"location":"manual/public/#nnmm*get*genotypes","page":"Public Functions","title":"nnmmgetgenotypes","text":"Read genotype data from a file or matrix.","category":"section"},{"location":"manual/public/#get_genotypes","page":"Public Functions","title":"get_genotypes","text":"Alias for nnmm_get_genotypes.","category":"section"},{"location":"manual/public/#nnmm*get*omics","page":"Public Functions","title":"nnmmgetomics","text":"Read omics data from a file.","category":"section"},{"location":"manual/public/#Post-Analysis-Functions","page":"Public Functions","title":"Post-Analysis Functions","text":"","category":"section"},{"location":"manual/public/#GWAS","page":"Public Functions","title":"GWAS","text":"Genome-wide association study on MCMC results.\n\nUsage:\n\n# Run GWAS on marker effect samples\ngwas_result = GWAS(\"results/MCMC_samples_marker_effects_geno_omic1.txt\")\n\n# Sort by model frequency\nsorted = sort(gwas_result, :modelfrequency, rev=true)\nprintln(first(sorted, 10))","category":"section"},{"location":"manual/public/#getEBV","page":"Public Functions","title":"getEBV","text":"Extract estimated breeding values from results.","category":"section"},{"location":"manual/public/#Built-in-Datasets","page":"Public Functions","title":"Built-in Datasets","text":"","category":"section"},{"location":"manual/public/#dataset","page":"Public Functions","title":"dataset","text":"Access built-in example datasets.\n\nUsage:\n\nusing NNMM.Datasets\n\n# Access default example data\npheno_path = Datasets.dataset(\"phenotypes.csv\")\ngeno_path = Datasets.dataset(\"genotypes.csv\")\n\n# Access simulated omics dataset\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\nAvailable Datasets:\n\nDataset Files Description\n(default) phenotypes.csv, genotypes.csv, genotypes0.csv, pedigree.csv, GRM.csv, map.csv Small example data\n(default) genotypes_group1.csv, genotypes_group2.csv, genotypes_group3.csv Genotype groups for partial networks\nexample phenotypes.txt, genotypes.txt, pedigree.txt, etc. Tab-separated example data\nsimulated_omics_data genotypes_1000snps.txt, phenotypes_sim.txt, pedigree.txt Simulated dataset with 1000 SNPs and 10 omics","category":"section"},{"location":"manual/public/#Pedigree-Functions","page":"Public Functions","title":"Pedigree Functions","text":"","category":"section"},{"location":"manual/public/#get_pedigree","page":"Public Functions","title":"get_pedigree","text":"Read and process pedigree information.\n\nUsage:\n\n# Read pedigree file\npedigree = get_pedigree(\"pedigree.csv\", separator=',', header=true)\n\n# Use in random effect specification\nrandom_spec = [(name=\"ID\", pedigree=pedigree)]","category":"section"},{"location":"manual/public/#Parameter-Reference-Tables","page":"Public Functions","title":"Parameter Reference Tables","text":"","category":"section"},{"location":"manual/public/#Bayesian-Methods","page":"Public Functions","title":"Bayesian Methods","text":"Method Description\n\"BayesA\" All markers have non-zero effects with marker-specific variances\n\"BayesB\" Subset of markers have non-zero effects with marker-specific variances\n\"BayesC\" Subset of markers have non-zero effects with common variance\n\"BayesL\" Bayesian LASSO\n\"RR-BLUP\" Ridge regression BLUP (all markers, common variance)\n\"GBLUP\" Genomic BLUP using relationship matrix (Layer 1→2 only)","category":"section"},{"location":"manual/public/#Activation-Functions","page":"Public Functions","title":"Activation Functions","text":"Function Formula Range Use Case\n\"linear\" f(x) = x (-∞, ∞) Traditional regression\n\"sigmoid\" f(x) = 1/(1+e^(-x)) (0, 1) Bounded outputs\n\"tanh\" f(x) = tanh(x) (-1, 1) Centered bounded outputs\n\"relu\" f(x) = max(0, x) [0, ∞) Sparse activation\n\"leakyrelu\" f(x) = max(0.01x, x) (-∞, ∞) Sparse with gradient flow","category":"section"},{"location":"manual/public/#runNNMM-Keyword-Arguments","page":"Public Functions","title":"runNNMM Keyword Arguments","text":"Argument Type Default Description\nchain_length Integer 100 Total MCMC iterations\nburnin Integer 0 Burn-in iterations to discard\noutput_samples_frequency Integer auto Save every Nth sample\noutputEBV Bool true Output estimated breeding values\noutput_heritability Bool true Calculate heritability\noutput_folder String \"nnmm_results\" Output directory\nseed Int/Bool false Random seed (false = random)\nprintout_frequency Integer chain_length+1 Print progress frequency\ndouble_precision Bool false Use Float64 instead of Float32\nbig_memory Bool false Enable memory-intensive optimizations","category":"section"},{"location":"manual/public/#NNMM.Layer","page":"Public Functions","title":"NNMM.Layer","text":"Layer\n\nA struct representing a layer in the Neural Network Mixed Model (NNMM).\n\nFields\n\nlayer_name::String: Name identifier for the layer\ndata_path: Path to the data file(s) - String for single file, Vector{String} for partial connection\nseparator: Column separator in the data file (default: ',')\nheader: Whether the data file has a header row (default: true)\ndata: Loaded data (initialized as empty)\nquality_control: Whether to perform quality control on genotypes (default: true)\nMAF: Minor Allele Frequency threshold for QC (default: 0.01)\nmissing_value: Value representing missing data (default: 9.0)\ncenter: Whether to center the data (default: true)\n\n\n\n\n\n","category":"type"},{"location":"manual/public/#NNMM.Equation","page":"Public Functions","title":"NNMM.Equation","text":"Equation\n\nA struct representing an equation connecting layers in NNMM.\n\nFields\n\nfrom_layer_name: Source layer name\nto_layer_name: Target layer name\nequation: Model equation string\nomics_name: Names of omics variables (or false if not applicable)\nphenotype_name: Names of phenotype variables (or false if not applicable)\ncovariate: Covariate variable names\nrandom: Random effect specifications\nactivation_function: Activation function (\"linear\", \"sigmoid\", \"tanh\", etc.)\npartial_connect_structure: Structure for partial connectivity\nstarting_value: Starting values for MCMC\nmethod: Bayesian method (\"BayesC\", \"BayesA\", \"BayesB\", etc.)\nPi: Prior probability of zero effect\nestimatePi: Whether to estimate Pi\nVariance parameters for G (genetic) and R (residual)\n\n\n\n\n\n","category":"type"},{"location":"manual/public/#NNMM.Omics","page":"Public Functions","title":"NNMM.Omics","text":"Omics\n\nA struct representing omics data (e.g., transcriptomics, metabolomics) in NNMM.\n\nFields\n\nname: Name identifier for this omics category\ntrait_names: Names for corresponding traits\nobsID: Row IDs for individuals\nfeatureID: Feature/omics variable IDs\nnObs: Number of observations\nnFeatures: Number of omics features\nnMarkers: Alias for nFeatures (compatibility)\ncentered: Whether data is centered\ndata: The omics data matrix\nntraits: Number of traits in the model\nAdditional fields for Bayesian MCMC computations\n\n\n\n\n\n","category":"type"},{"location":"manual/public/#NNMM.Phenotypes","page":"Public Functions","title":"NNMM.Phenotypes","text":"Phenotypes\n\nA struct representing phenotype data in NNMM.\n\nFields\n\nobsID: Individual IDs\nfeatureID: Phenotype/trait names\nnObs: Number of observations\nnPheno: Number of phenotypes\ndata: Phenotype data matrix\nnFeatures: Alias for nPheno\n\n\n\n\n\n","category":"type"},{"location":"manual/public/#NNMM.runNNMM","page":"Public Functions","title":"NNMM.runNNMM","text":"runNNMM(layers, equations; kwargs...)\n\nRun Neural Network Mixed Model (NNMM) analysis.\n\nArguments\n\nlayers: Vector of 3 Layer objects defining the network architecture\nLayer 1: Genotypes (SNPs)\nLayer 2: Omics/Latent traits\nLayer 3: Phenotypes\nequations: Vector of 2 Equation objects defining relationships\nEquation 1: Genotypes → Omics (1→2)\nEquation 2: Omics → Phenotypes (2→3)\n\nKeyword Arguments\n\nMCMC Settings\n\nchain_length::Integer=100: Total MCMC iterations\nburnin::Integer=0: Number of burn-in iterations to discard\noutput_samples_frequency::Integer: Save every nth sample (default: auto)\nupdate_priors_frequency::Integer=0: Update prior parameters every n iterations\n\nOutput Settings\n\noutputEBV=true: Output estimated breeding values\noutput_heritability=true: Calculate heritability estimates\noutput_folder=\"nnmm_results\": Directory for output files\n\nComputational Settings\n\nseed=false: Random seed for reproducibility\ndouble_precision=false: Use Float64 instead of Float32\nbig_memory=false: Enable memory-intensive optimizations\n\nReturns\n\nA dictionary containing:\n\nPosterior means for all parameters\nMCMC samples (saved to files)\nEBV estimates\n\nExample\n\n# Define layers\nlayer1 = Layer(name=\"geno\", file=\"genotypes.csv\")\nlayer2 = Layer(name=\"omics\", file=\"omics.csv\")\nlayer3 = Layer(name=\"pheno\", file=\"phenotypes.csv\")\n\n# Define equations\neq1 = Equation(\"omics = intercept + geno\", \n               method=\"BayesC\", omics_name=[\"o1\",\"o2\"])\neq2 = Equation(\"pheno = intercept + omics\", \n               activation_function=tanh, phenotype_name=[\"y\"])\n\n# Run analysis\nresults = runNNMM([layer1, layer2, layer3], [eq1, eq2],\n                  chain_length=5000, burnin=1000)\n\nSee also: Layer, Equation, describe\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#DataAPI.describe","page":"Public Functions","title":"DataAPI.describe","text":"describe(model::MME)\n\nPrint a summary of the mixed model equations (MME) structure.\n\nDisplays:\n\nModel equations (truncated if >5)\nTerm information (classification, fixed/random, number of levels)\nPrior distributions and hyperparameters\nVariance component settings\nMarker effect settings (if genomic data included)\n\nArguments\n\nmodel::MME: The mixed model equations object (created internally by runNNMM)\n\nOutput\n\nPrints formatted model summary to stdout including:\n\nModel equations\nTerm classification (covariate/factor, fixed/random)\nPrior settings for variance components\nMCMC configuration\n\nExample\n\n# After running runNNMM, the describe function is called automatically.\n# For manual inspection:\ndescribe(results[\"mme\"])\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.read_phenotypes","page":"Public Functions","title":"NNMM.read_phenotypes","text":"read_phenotypes(file; separator=',', header=true, missing_value=\"NA\", output_folder=\".\")\n\nRead phenotype data from a CSV file.\n\nArguments\n\nfile: Path to CSV file containing phenotype data\n\nKeyword Arguments\n\nseparator: Column delimiter (default: ',')\nheader: Whether file has header row (default: true)\nmissing_value: String representing missing values (default: \"NA\")\noutput_folder: Directory for output files (default: current directory)\n\nReturns\n\nDataFrame with phenotype data. First column is individual IDs.\n\nExample\n\npheno_df = read_phenotypes(\"phenotypes.csv\", missing_value=\"NA\")\n\nNotes\n\nFirst column must contain individual IDs\nMissing values are converted to Julia's missing type\nA file IDs_for_individuals_with_phenotypes.txt is written to output_folder\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.nnmm_get_genotypes","page":"Public Functions","title":"NNMM.nnmm_get_genotypes","text":"nnmm_get_genotypes(file, G=false; kwargs...)\n\nRead genotype data for the NNMM model (layer 1).\n\nArguments\n\nfile: Genotype data source - can be:\nString: Path to CSV file\nDataFrame: DataFrame with ID column + marker columns\nMatrix: Numeric matrix of genotypes\nG: Prior genetic variance (default: estimated from data)\n\nKeyword Arguments\n\nmethod: Bayesian method (\"BayesA\", \"BayesB\", \"BayesC\", \"RR-BLUP\", \"GBLUP\", \"BayesL\")\nPi: Prior inclusion probability (default: 0.0)\nestimatePi: Whether to estimate Pi (default: true)\nG_is_marker_variance: If true, G is marker variance; if false, G is genetic variance\ndf: Degrees of freedom for prior (default: 4.0)\nquality_control: Perform QC filtering (default: true)\nMAF: Minor allele frequency threshold (default: 0.01)\ncenter: Center genotypes (default: true)\nseparator: File delimiter (default: ',')\nheader: File has header row (default: true)\n\nReturns\n\nGenotypes struct containing processed genotype data and method parameters.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.get_genotypes","page":"Public Functions","title":"NNMM.get_genotypes","text":"get_genotypes(args...; kwargs...)\n\nAlias for nnmm_get_genotypes. See that function for full documentation.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.nnmm_get_omics","page":"Public Functions","title":"NNMM.nnmm_get_omics","text":"nnmm_get_omics(file, G=false; kwargs...)\n\nRead omics data for the NNMM model (layer 2 / middle layer).\n\nArguments\n\nfile: Path to CSV file containing omics data\nG: Prior genetic variance (default: estimated from data)\n\nKeyword Arguments\n\nomics_name: Vector of column names to use as omics features (required)\nmethod: Bayesian method (\"BayesA\", \"BayesB\", \"BayesC\", \"RR-BLUP\", \"BayesL\")\nPi: Prior inclusion probability (default: 0.0)\nestimatePi: Whether to estimate Pi (default: true)\nG_is_marker_variance: If true, G is marker variance; if false, G is genetic variance\ndf: Degrees of freedom for prior (default: 4.0)\nconstraint: Use independent variances for multi-trait (default: true)\nseparator: File delimiter (default: ',')\nheader: File has header row (default: true)\nmissing_value: String/value representing missing data (default: false)\n\nReturns\n\nOmics struct containing the omics data and method parameters.\n\nExample\n\nomics = nnmm_get_omics(\"omics_data.csv\", \n                       omics_name=[\"gene1\", \"gene2\", \"gene3\"],\n                       missing_value=\"NA\")\n\nNotes\n\nFirst column must be individual IDs\nMissing values will be sampled during MCMC (HMC for latent traits)\nUnlike genotypes, no quality control (MAF filtering) is applied\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.GWAS","page":"Public Functions","title":"NNMM.GWAS","text":"GWAS(marker_effects_file; header=true)\n\nCompute the model frequency for each marker.\n\nModel frequency is the probability that a marker is included in the model (i.e., has non-zero effect) across MCMC samples.\n\nArguments\n\nmarker_effects_file: Path to CSV file with MCMC samples of marker effects\nheader: Whether file has header row (default: true)\n\nReturns\n\nDataFrame with columns:\n\nmarker_ID: Marker identifier\nmodelfrequency: Proportion of samples where effect ≠ 0\n\nExample\n\n# After running NNMM with BayesB or BayesC\nfreq = GWAS(\"nnmm_results/MCMC_samples_marker_effects_genotypes.txt\")\n\n\n\n\n\nGWAS(model,map_file,marker_effects_file...;\n     window_size = \"1 Mb\",sliding_window = false,\n     GWAS = true, threshold = 0.001,\n     genetic_correlation = false,\n     header = true)\n\nrun genomic window-based GWAS\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nmodel is either the model::MME used in analysis or the genotype cavariate matrix M::Array\nmap_file has the (sorted) marker position information with delimiter ','. If the map file is not provided, i.e., map_file=false, a fake map file will be generated with window_size markers in each 1 Mb window, and each 1 Mb window will be tested.\nIf two markereffectsfile are provided, and genetic_correlation = true, genomic correlation for each window is calculated.\nStatistics are computed for nonoverlapping windows of size window_size by default. If sliding_window = true, those for overlapping sliding windows are calculated.\nmap file format:\n\nmarkerID,chromosome,position\nm1,1,16977\nm2,1,434311\nm3,1,1025513\nm4,2,70350\nm5,2,101135\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.getEBV","page":"Public Functions","title":"NNMM.getEBV","text":"getEBV(model::MME,traiti)\n\n(internal function) Get breeding values for individuals defined by outputEBV(), defaulting to all genotyped individuals. This function is used inside MCMC functions for one MCMC samples from posterior distributions. e.g., non-NNBayespartial (multi-classs Bayes) : y1=M1α1[1]+M2α2[1]+M3α3[1]                                            y2=M1α1[2]+M2α2[2]+M3α3[2]; NNBayespartial:     y1=M1α1[1]                      y2=M2α2[1]                      y3=M3*α3[1];\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.Datasets.dataset","page":"Public Functions","title":"NNMM.Datasets.dataset","text":"dataset(file_name::AbstractString; dataset_name::AbstractString=\"\")\n\nGet the path to a built-in dataset file.\n\nArguments\n\nfile_name::AbstractString: The name of the file to retrieve\ndataset_name::AbstractString=\"\": Optional subdirectory name within the data folder\n\nReturns\n\nString: Full path to the requested data file\n\nExamples\n\nphenofile = dataset(\"phenotypes.csv\")\ngenofile = dataset(\"genotypes.txt\", dataset_name=\"example\")\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#NNMM.PedModule.get_pedigree","page":"Public Functions","title":"NNMM.PedModule.get_pedigree","text":"get_pedigree(pedfile::AbstractString;header=false,separator=',',missingstrings=[\"0\"],output_folder=\".\")\n\nGet pedigree informtion from a pedigree file with header (defaulting to false) , separator (defaulting to ,) and missing values (defaulting to [\"0\"])\noutput_folder: Directory to save diagnostic files (defaulting to current directory)\nPedigree file format:\n\na,0,0\nc,a,b\nd,a,c\n\n\n\n\n\n","category":"function"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Part-4:-Partial-Connected-Neural-Networks","page":"Part 4. Partial connected neural network","title":"Part 4: Partial-Connected Neural Networks","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Model-Architecture","page":"Part 4. Partial connected neural network","title":"Model Architecture","text":"In partial-connected neural networks, SNPs can be divided into groups by users, and each group connects to its own intermediate trait in the middle layer. This is useful when:\n\nDifferent genomic regions affect different intermediate traits\nYou want to model pathway-specific effects\nYou have prior biological knowledge about SNP-trait relationships\n\n  Genotype Group 1 ─────► Omics/Latent 1 ─┐\n  Genotype Group 2 ─────► Omics/Latent 2 ─┼──► Phenotype\n  Genotype Group 3 ─────► Omics/Latent 3 ─┘\n\nimportant: Partial Connection Setup\nTo create a partial-connected network, provide multiple genotype files in the data_path parameter as a vector. The number of genotype files must equal the number of omics features.\n\nwarning: Known Bug\nPartial-connected networks currently have a bug (wArray2 undefined error) that prevents  them from running successfully. This will be fixed in a future release. For now, use  fully-connected networks as a workaround.\n\nimportant: Data Requirements\nAll genotype files and phenotype files must have matching individual IDs. This example uses  the simulated_omics_data dataset which has 3534 aligned individuals.","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Example:-Partial-Connected-Network-with-Observed-Omics","page":"Part 4. Partial connected neural network","title":"Example: Partial-Connected Network with Observed Omics","text":"This example demonstrates:\n\nNumber of genotype groups: 3 (simulated by splitting SNPs)\nNumber of omics features: 3 (one per genotype group)\nBayesian method: BayesC\nActivation function: sigmoid\n\n(Image: )\n\n# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Load simulated data\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Step 3: Split genotypes into 3 groups (for demonstration)\n# Read full genotype file and split into 3 parts\ngeno_full = CSV.read(geno_path, DataFrame)\nn_markers = ncol(geno_full) - 1  # Exclude ID column\nmarkers_per_group = div(n_markers, 3)\n\n# Create 3 genotype group files\ngeno1_cols = vcat(:ID, names(geno_full)[2:markers_per_group+1])\ngeno2_cols = vcat(:ID, names(geno_full)[markers_per_group+2:2*markers_per_group+1])\ngeno3_cols = vcat(:ID, names(geno_full)[2*markers_per_group+2:end])\n\ngeno1_df = geno_full[:, geno1_cols]\ngeno2_df = geno_full[:, geno2_cols]\ngeno3_df = geno_full[:, geno3_cols]\n\ngenofile1 = \"geno_group1.csv\"\ngenofile2 = \"geno_group2.csv\"\ngenofile3 = \"geno_group3.csv\"\n\nCSV.write(genofile1, geno1_df)\nCSV.write(genofile2, geno2_df)\nCSV.write(genofile3, geno3_df)\n\n# Step 4: Create omics file (3 features, one per genotype group)\nomics_df = pheno_df[:, [:ID, :omic1, :omic2, :omic3]]\nomics_file = \"omics_partial.csv\"\nCSV.write(omics_file, omics_df; missingstring=\"NA\")\n\n# Step 5: Create phenotype file\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_file = \"trait_partial.csv\"\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\n# Step 6: Define layers\n# KEY: Provide multiple genotype files as a vector for partial connection\nlayers = [\n    # Layer 1: Multiple genotype files = partial-connected network\n    Layer(\n        layer_name = \"geno\",\n        data_path = [genofile1, genofile2, genofile3]  # Vector of 3 files\n    ),\n    # Layer 2: Observed omics (one per genotype group)\n    Layer(\n        layer_name = \"omics\",\n        data_path = omics_file,\n        missing_value = \"NA\"\n    ),\n    # Layer 3: Phenotypes\n    Layer(\n        layer_name = \"phenotypes\",\n        data_path = trait_file,\n        missing_value = \"NA\"\n    )\n]\n\n# Step 7: Define equations\n# The equation uses a single layer name (\"geno\"), but NNMM internally\n# creates separate equations for each genotype group (geno1, geno2, geno3)\nequations = [\n    Equation(\n        from_layer_name = \"geno\",\n        to_layer_name = \"omics\",\n        equation = \"omics = intercept + geno\",  # Internal: omic1=intercept+geno1; omic2=intercept+geno2; omic3=intercept+geno3\n        omics_name = [\"omic1\", \"omic2\", \"omic3\"],  # Must match number of genotype files\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    Equation(\n        from_layer_name = \"omics\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + omics\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"sigmoid\"\n    )\n]\n\n# Step 8: Run analysis\nout = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    output_folder = \"nnmm_partial_results\"\n)\n\n# Step 9: Check accuracy\nebv = out[\"EBV_NonLinear\"]\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\nresults = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\naccuracy = cor(Float64.(results.EBV), results.genetic_total)\nprintln(\"Prediction accuracy: \", round(accuracy, digits=4))\n\n# Cleanup\nrm(genofile1, force=true)\nrm(genofile2, force=true)\nrm(genofile3, force=true)\nrm(omics_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Example:-Partial-Connected-Network-with-Latent-Traits","page":"Part 4. Partial connected neural network","title":"Example: Partial-Connected Network with Latent Traits","text":"When you don't have observed omics data but want to use a partial-connected architecture:\n\n# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Load simulated data and split genotypes (same as above)\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\ngeno_full = CSV.read(geno_path, DataFrame)\nn_markers = ncol(geno_full) - 1\nmarkers_per_group = div(n_markers, 3)\n\ngeno1_cols = vcat(:ID, names(geno_full)[2:markers_per_group+1])\ngeno2_cols = vcat(:ID, names(geno_full)[markers_per_group+2:2*markers_per_group+1])\ngeno3_cols = vcat(:ID, names(geno_full)[2*markers_per_group+2:end])\n\nCSV.write(\"geno_group1.csv\", geno_full[:, geno1_cols])\nCSV.write(\"geno_group2.csv\", geno_full[:, geno2_cols])\nCSV.write(\"geno_group3.csv\", geno_full[:, geno3_cols])\n\n# Step 3: Create latent trait file (all missing)\nn_individuals = nrow(pheno_df)\nlatent_df = DataFrame(\n    ID = pheno_df.ID,\n    latent1 = fill(missing, n_individuals),\n    latent2 = fill(missing, n_individuals),\n    latent3 = fill(missing, n_individuals)\n)\nCSV.write(\"latent_partial.csv\", latent_df; missingstring=\"NA\")\n\n# Step 4: Create phenotype file\nCSV.write(\"trait_partial.csv\", pheno_df[:, [:ID, :trait1]]; missingstring=\"NA\")\n\n# Step 5: Define layers\nlayers = [\n    Layer(layer_name=\"geno\", data_path=[\"geno_group1.csv\", \"geno_group2.csv\", \"geno_group3.csv\"]),\n    Layer(layer_name=\"latent\", data_path=\"latent_partial.csv\", missing_value=\"NA\"),\n    Layer(layer_name=\"phenotypes\", data_path=\"trait_partial.csv\", missing_value=\"NA\")\n]\n\n# Step 6: Define equations\nequations = [\n    Equation(from_layer_name=\"geno\", to_layer_name=\"latent\",\n             equation=\"latent = intercept + geno\",\n             omics_name=[\"latent1\", \"latent2\", \"latent3\"], method=\"BayesC\"),\n    Equation(from_layer_name=\"latent\", to_layer_name=\"phenotypes\",\n             equation=\"phenotypes = intercept + latent\",\n             phenotype_name=[\"trait1\"], activation_function=\"tanh\")\n]\n\n# Step 7: Run analysis\nout = runNNMM(layers, equations; chain_length=5000, burnin=1000, output_folder=\"nnmm_partial_latent\")\n\n# Step 8: Check accuracy\nebv = out[\"EBV_NonLinear\"]\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\nresults = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\nprintln(\"Accuracy: \", round(cor(Float64.(results.EBV), results.genetic_total), digits=4))\n\n# Cleanup\nfor f in [\"geno_group1.csv\", \"geno_group2.csv\", \"geno_group3.csv\", \"latent_partial.csv\", \"trait_partial.csv\"]\n    rm(f, force=true)\nend","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Key-Points","page":"Part 4. Partial connected neural network","title":"Key Points","text":"Number of files = Number of omics: The number of genotype files must exactly match the number of omics/latent features.\nAutomatic naming: When you provide 3 genotype files and layer_name=\"geno\", NNMM internally names them geno1, geno2, geno3.\nIndependent models: Each genotype group gets its own independent Bayesian model for predicting its corresponding omics feature.\nMixed with residuals: You can add extra latent nodes for residual effects by including additional (all-missing) columns in the omics file.","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Comparison:-Fully-Connected-vs-Partial-Connected","page":"Part 4. Partial connected neural network","title":"Comparison: Fully-Connected vs Partial-Connected","text":"Aspect Fully-Connected Partial-Connected\nGenotype input Single file (vector with 1 element) Multiple files (vector with N elements)\nConnectivity All SNPs → All omics SNP group i → Omics i\nMarker effects Shared across omics Group-specific\nUse case General prediction Pathway-specific modeling","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Output-Files","page":"Part 4. Partial connected neural network","title":"Output Files","text":"Output files are similar to fully-connected networks, but with group-specific marker effect files:\n\nMCMC_samples_marker_effects_geno1_omic1.txt\nMCMC_samples_marker_effects_geno2_omic2.txt\nMCMC_samples_marker_effects_geno3_omic3.txt","category":"section"},{"location":"citing/citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing/citing/#Software","page":"Citing","title":"Software","text":"If you use NNMM.jl, please cite:\n\nZhao, T., Zeng, J., & Cheng, H. (2022). Extend mixed models to multilayer neural networks for genomic prediction including intermediate omics data. GENETICS, iyac034. https://doi.org/10.1093/genetics/iyac034\nZhao, T., Fernando, R., & Cheng, H. (2021). Interpretable artificial neural networks incorporating Bayesian alphabet models for genome-wide prediction and association studies. G3 Genes|Genomes|Genetics, jkab228. https://doi.org/10.1093/g3journal/jkab228","category":"section"},{"location":"citing/citing/#Methods","page":"Citing","title":"Methods","text":"","category":"section"},{"location":"citing/citing/#Neural-Network-Mixed-Models-(NNMM)","page":"Citing","title":"Neural Network Mixed Models (NNMM)","text":"Zhao T, Zeng J, Cheng H. 2022. Extend mixed models to multilayer neural networks for genomic prediction including intermediate omics data. GENETICS, iyac034.\nZhao T, Fernando R, Cheng H. 2021. Interpretable artificial neural networks incorporating Bayesian alphabet models for genome-wide prediction and association studies. G3 Genes|Genomes|Genetics, jkab228.","category":"section"},{"location":"citing/citing/#Bayesian-Alphabet-Methods","page":"Citing","title":"Bayesian Alphabet Methods","text":"Meuwissen T, Hayes B, Goddard M. 2001. Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157:1819–1829.\nHabier D, Fernando R, Kizilkaya K, Garrick D. 2011. Extension of the bayesian alphabet for genomic selection. BMC Bioinformatics, 12(1), 186.\nCheng H, Garrick D, Fernando R. 2015. A fast and efficient Gibbs sampler for BayesB in whole-genome analyses. Genet Sel Evol, 47:80.\nCheng H, Kizilkaya K, Zeng J, Garrick D, Fernando R. 2018. Genomic Prediction from Multiple-Trait Bayesian Regression Methods Using Mixture Priors. Genetics, 209(1): 89-103.","category":"section"},{"location":"citing/citing/#Single-step-Methods","page":"Citing","title":"Single-step Methods","text":"Fernando R, Dekkers J, Garrick D. 2015. A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Genetics Selection Evolution, 46(1), 50.\nFernando R, Cheng H, Golden B, Garrick D. 2016. Computational strategies for alternative single-step Bayesian regression models with large numbers of genotyped and non-genotyped animals. Genetics Selection Evolution, 48(1), 96.","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Part-5:-User-Defined-Nonlinear-Functions","page":"Part 5. User-defined nonlinear function","title":"Part 5: User-Defined Nonlinear Functions","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.\n\nwarning: Known Limitation\nUser-defined activation functions are not currently supported due to a type constraint in the  Equation struct (which requires activation_function::String). Use the built-in activation  functions (\"linear\", \"sigmoid\", \"tanh\", \"relu\", \"leakyrelu\") instead.This feature is planned for a future release.","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Overview","page":"Part 5. User-defined nonlinear function","title":"Overview","text":"The intention is to allow custom nonlinear relationships between the middle layer (intermediate traits) and the output layer (phenotype), instead of using built-in activation functions.\n\nThis would be useful when:\n\nYou have domain knowledge about the biological relationship\nThe phenotype follows a specific mechanistic model\nStandard activation functions don't capture the true relationship","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Current-Status","page":"Part 5. User-defined nonlinear function","title":"Current Status","text":"The Equation struct currently defines:\n\nactivation_function::String  # Only accepts string values\n\nAlthough the internal code has provisions for user-defined functions, the type constraint prevents passing functions directly.","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Workaround:-Use-Built-in-Activation-Functions","page":"Part 5. User-defined nonlinear function","title":"Workaround: Use Built-in Activation Functions","text":"Until this feature is implemented, use the closest built-in activation function:\n\n# For bounded outputs (0 to 1)\nEquation(..., activation_function = \"sigmoid\")\n\n# For bounded outputs (-1 to 1)\nEquation(..., activation_function = \"tanh\")\n\n# For unbounded linear relationships\nEquation(..., activation_function = \"linear\")\n\n# For sparse/rectified outputs\nEquation(..., activation_function = \"relu\")\nEquation(..., activation_function = \"leakyrelu\")","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Example:-Using-tanh-as-Alternative-to-Custom-Function","page":"Part 5. User-defined nonlinear function","title":"Example: Using tanh as Alternative to Custom Function","text":"If you need a custom function like:\n\ny = sqrtfracx_1^2x_1^2 + x_2^2\n\nConsider using tanh which provides similar bounded nonlinear behavior:\n\n# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Load data\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Step 3: Create latent trait file (2 latent nodes)\nn_individuals = nrow(pheno_df)\nlatent_df = DataFrame(\n    ID = pheno_df.ID,\n    latent1 = fill(missing, n_individuals),\n    latent2 = fill(missing, n_individuals)\n)\nlatent_file = \"latent_custom.csv\"\nCSV.write(latent_file, latent_df; missingstring=\"NA\")\n\n# Step 4: Create phenotype file\ntrait_file = \"trait_custom.csv\"\nCSV.write(trait_file, pheno_df[:, [:ID, :trait1]]; missingstring=\"NA\")\n\n# Step 5: Define layers\nlayers = [\n    Layer(layer_name = \"genotypes\", data_path = [geno_path]),\n    Layer(layer_name = \"latent\", data_path = latent_file, missing_value = \"NA\"),\n    Layer(layer_name = \"phenotypes\", data_path = trait_file, missing_value = \"NA\")\n]\n\n# Step 6: Define equations with built-in tanh (workaround for custom function)\nequations = [\n    Equation(\n        from_layer_name = \"genotypes\",\n        to_layer_name = \"latent\",\n        equation = \"latent = intercept + genotypes\",\n        omics_name = [\"latent1\", \"latent2\"],\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    Equation(\n        from_layer_name = \"latent\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + latent\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"tanh\"  # Use built-in function instead\n    )\n]\n\n# Step 7: Run analysis\nout = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    output_folder = \"nnmm_tanh_results\"\n)\n\n# Step 8: Check results\nebv = out[\"EBV_NonLinear\"]\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\nresults = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\naccuracy = cor(Float64.(results.EBV), results.genetic_total)\nprintln(\"Prediction accuracy: \", round(accuracy, digits=4))\n\n# Cleanup\nrm(latent_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Comparison:-Built-in-Activation-Functions","page":"Part 5. User-defined nonlinear function","title":"Comparison: Built-in Activation Functions","text":"Function Formula Range Use Case\n\"linear\" f(x) = x (-∞, ∞) Traditional regression, additive models\n\"sigmoid\" f(x) = 1/(1+e^(-x)) (0, 1) Bounded outputs, probabilities\n\"tanh\" f(x) = tanh(x) (-1, 1) Centered bounded outputs\n\"relu\" f(x) = max(0, x) [0, ∞) Sparse activation, positive outputs\n\"leakyrelu\" f(x) = max(0.01x, x) (-∞, ∞) Sparse with gradient flow","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Future:-Planned-User-Defined-Function-Support","page":"Part 5. User-defined nonlinear function","title":"Future: Planned User-Defined Function Support","text":"When implemented, the syntax would be:\n\n# NOT YET SUPPORTED - Future syntax\ncustom_fn(x1, x2) = sqrt(x1^2 / (x1^2 + x2^2 + 1e-8))\n\nequations = [\n    ...,\n    Equation(\n        ...,\n        activation_function = custom_fn  # Will be supported in future\n    )\n]","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Expected-Behavior-(Future)","page":"Part 5. User-defined nonlinear function","title":"Expected Behavior (Future)","text":"When using a user-defined function:\n\nMissing latent traits: Would be sampled via Metropolis-Hastings (not HMC)\nReason: Automatic differentiation for HMC may not work with arbitrary user functions","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#Tips","page":"Part 5. User-defined nonlinear function","title":"Tips","text":"Choose closest built-in: Select the built-in function that best approximates your desired behavior.\nTransform data: Pre-transform your phenotype data to better match available activation functions.\nCheck documentation: Monitor NNMM.jl releases for user-defined function support.\nFeature request: If you need custom functions urgently, open an issue on the GitHub repository.","category":"section"},{"location":"manual/tutorial/#Step-by-Step-Tutorial","page":"Tutorial","title":"Step-by-Step Tutorial","text":"note: Version Compatibility\nThis tutorial uses NNMM.jl v0.3+ with the Layer/Equation/runNNMM API.\n\nThis tutorial walks through a complete NNMM analysis using the built-in simulated dataset.","category":"section"},{"location":"manual/tutorial/#Overview","page":"Tutorial","title":"Overview","text":"We'll perform genomic prediction using a three-layer Neural Network Mixed Model:\n\nGenotypes (SNPs) → Omics (gene expression) → Phenotype (trait)\n     Layer 1            Layer 2                  Layer 3\n\nThis architecture allows us to:\n\nModel the biological pathway from DNA to gene expression to phenotype\nHandle missing omics data via HMC sampling\nObtain estimated breeding values (EBV) for selection","category":"section"},{"location":"manual/tutorial/#Step-1:-Load-Packages-and-Data","page":"Tutorial","title":"Step 1: Load Packages and Data","text":"using NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\n# Set seed for reproducibility\nRandom.seed!(42)\n\n# Load built-in simulated dataset paths\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\n# Check the data\nprintln(\"Genotype file: \", geno_path)\nprintln(\"Phenotype file: \", pheno_path)\n\nExpected output:\n\nGenotype file: /path/to/NNMM.jl/src/datasets/data/simulated_omics_data/genotypes_1000snps.txt\nPhenotype file: /path/to/NNMM.jl/src/datasets/data/simulated_omics_data/phenotypes_sim.txt","category":"section"},{"location":"manual/tutorial/#Step-2:-Prepare-Data-Files","page":"Tutorial","title":"Step 2: Prepare Data Files","text":"The phenotype file contains both omics and trait data. NNMM requires separate files for omics (Layer 2) and phenotypes (Layer 3):\n\n# Read the combined phenotype file\npheno_df = CSV.read(pheno_path, DataFrame)\nprintln(\"Columns: \", names(pheno_df))\n# Expected: [:ID, :omic1, ..., :omic10, :trait1, :genetic_total, ...]\n\n# Create omics file (10 omics features)\nomics_cols = vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])\nomics_df = pheno_df[:, omics_cols]\nomics_file = \"omics_data.csv\"\nCSV.write(omics_file, omics_df; missingstring=\"NA\")\n\n# Create phenotype file (single trait)\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_file = \"phenotypes.csv\"\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\nprintln(\"Created: $omics_file and $trait_file\")\nprintln(\"Number of individuals: \", nrow(pheno_df))\nprintln(\"Number of omics features: \", length(omics_cols) - 1)","category":"section"},{"location":"manual/tutorial/#Step-3:-Define-the-Network-Architecture","page":"Tutorial","title":"Step 3: Define the Network Architecture","text":"NNMM uses Layer structs to define each layer in the network:\n\n# Define the three layers\nlayers = [\n    # Layer 1: Genotypes (input layer)\n    # Note: data_path is wrapped in [] for the genotype layer\n    Layer(\n        layer_name = \"genotypes\",\n        data_path = [geno_path]\n    ),\n    \n    # Layer 2: Omics (hidden/intermediate layer)\n    # Can contain missing values that will be sampled via HMC\n    Layer(\n        layer_name = \"omics\",\n        data_path = omics_file,\n        missing_value = \"NA\"\n    ),\n    \n    # Layer 3: Phenotypes (output layer)\n    Layer(\n        layer_name = \"phenotypes\",\n        data_path = trait_file,\n        missing_value = \"NA\"\n    )\n]","category":"section"},{"location":"manual/tutorial/#Layer-Parameters","page":"Tutorial","title":"Layer Parameters","text":"Parameter Description Default\nlayer_name Identifier used in equations Required\ndata_path Path to data file(s); use [path] for genotypes Required\nseparator Column delimiter ','\nheader File has header row true\nquality_control Perform MAF filtering (genotypes only) true\nMAF Minor allele frequency threshold 0.01\nmissing_value Value representing missing data 9.0\ncenter Center the data true","category":"section"},{"location":"manual/tutorial/#Step-4:-Define-the-Equations","page":"Tutorial","title":"Step 4: Define the Equations","text":"Equation structs connect layers and specify the statistical method:\n\nequations = [\n    # Equation 1: Layer 1 → Layer 2 (Genotypes predict omics)\n    Equation(\n        from_layer_name = \"genotypes\",\n        to_layer_name = \"omics\",\n        equation = \"omics = intercept + genotypes\",\n        omics_name = [\"omic$i\" for i in 1:10],  # Names of omics columns\n        method = \"BayesC\",                       # Bayesian method\n        estimatePi = true                        # Estimate marker inclusion probability\n    ),\n    \n    # Equation 2: Layer 2 → Layer 3 (Omics predict phenotype)\n    Equation(\n        from_layer_name = \"omics\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + omics\",\n        phenotype_name = [\"trait1\"],             # Names of phenotype columns\n        method = \"BayesC\",\n        estimatePi = true,\n        activation_function = \"linear\"           # Activation: \"linear\", \"sigmoid\", \"tanh\", \"relu\"\n    )\n]","category":"section"},{"location":"manual/tutorial/#Equation-Parameters","page":"Tutorial","title":"Equation Parameters","text":"Parameter Description Default\nfrom_layer_name Source layer name Required\nto_layer_name Target layer name Required\nequation Model equation string Required\nomics_name Names of omics variables (1→2 equation) false\nphenotype_name Names of phenotype variables (2→3 equation) false\nmethod Bayesian method: \"BayesA\", \"BayesB\", \"BayesC\", \"BayesL\", \"RR-BLUP\" \"BayesC\"\nactivation_function \"linear\", \"sigmoid\", \"tanh\", \"relu\", \"leakyrelu\" \"linear\"\nestimatePi Estimate marker inclusion probability true\ncovariate Covariate variable names (optional) false\nrandom Random effect specifications (optional) false","category":"section"},{"location":"manual/tutorial/#Step-5:-Run-the-Analysis","page":"Tutorial","title":"Step 5: Run the Analysis","text":"# Run NNMM with MCMC sampling\nresults = runNNMM(\n    layers, \n    equations;\n    chain_length = 5000,           # Number of MCMC iterations\n    burnin = 1000,                 # Burn-in iterations to discard\n    printout_frequency = 1000,     # Print progress every N iterations\n    output_folder = \"nnmm_output\"  # Where to save results\n)\n\ntip: For quick testing\nUse chain_length=100 for testing. For production, use at least chain_length=50000.","category":"section"},{"location":"manual/tutorial/#runNNMM-Parameters","page":"Tutorial","title":"runNNMM Parameters","text":"Parameter Description Default\nchain_length Total MCMC iterations 100\nburnin Burn-in iterations 0\noutput_samples_frequency Save every Nth sample auto\noutputEBV Output estimated breeding values true\noutput_heritability Calculate heritability true\noutput_folder Output directory \"nnmm_results\"\nseed Random seed for reproducibility false\ndouble_precision Use Float64 (slower, more precise) false","category":"section"},{"location":"manual/tutorial/#Step-6:-Examine-Results","page":"Tutorial","title":"Step 6: Examine Results","text":"","category":"section"},{"location":"manual/tutorial/#Estimated-Breeding-Values-(EBV)","page":"Tutorial","title":"Estimated Breeding Values (EBV)","text":"# Get EBV for all individuals\nebv = results[\"EBV_NonLinear\"]\nprintln(\"EBV for first 10 individuals:\")\ndisplay(first(ebv, 10))\n\n# Summary statistics (convert to Float64 for statistics)\nebv_vals = Float64.(ebv.EBV)\nprintln(\"\\nEBV summary:\")\nprintln(\"Mean: \", round(mean(ebv_vals), digits=3))\nprintln(\"Std:  \", round(std(ebv_vals), digits=3))\nprintln(\"Min:  \", round(minimum(ebv_vals), digits=3))\nprintln(\"Max:  \", round(maximum(ebv_vals), digits=3))","category":"section"},{"location":"manual/tutorial/#Available-Result-Keys","page":"Tutorial","title":"Available Result Keys","text":"# See all available results\nprintln(keys(results))\n\nCommon result keys:\n\n\"EBV_NonLinear\": Estimated breeding values (from predicted omics)\n\"EPV_NonLinear\": Estimated phenotypic values (from observed omics)\n\"EBV_omic1\", \"EBV_omic2\", ...: EBV for each omics trait","category":"section"},{"location":"manual/tutorial/#MCMC-Output-Files","page":"Tutorial","title":"MCMC Output Files","text":"The output folder contains MCMC samples for all parameters:\n\nFile Description\nMCMC_samples_marker_effects_*.txt Marker effect samples\nMCMC_samples_marker_effects_variances_*.txt Marker variance samples\nMCMC_samples_residual_variance.txt Residual variance samples\nMCMC_samples_pi_*.txt Marker inclusion probability samples\nMCMC_samples_EBV_*.txt EBV samples per trait/omics\nEBV_NonLinear.txt Posterior mean EBV\nEPV_NonLinear.txt Posterior mean EPV","category":"section"},{"location":"manual/tutorial/#Step-7:-Post-Analysis-with-GWAS","page":"Tutorial","title":"Step 7: Post-Analysis with GWAS","text":"Identify important markers using model frequency:\n\n# GWAS based on model frequency (probability marker is included)\nmarker_file = \"nnmm_output/MCMC_samples_marker_effects_genotypes_omic1.txt\"\nif isfile(marker_file)\n    gwas_result = GWAS(marker_file)\n    \n    # Top markers for omic1\n    sorted_gwas = sort(gwas_result, :modelfrequency, rev=true)\n    println(\"Top 10 markers for omic1:\")\n    display(first(sorted_gwas, 10))\nend","category":"section"},{"location":"manual/tutorial/#Complete-Script","page":"Tutorial","title":"Complete Script","text":"Here's the complete analysis in one runnable script:\n\n# Complete NNMM Analysis Script\n# Requires: NNMM.jl v0.3+\n\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\n# === Configuration ===\nRandom.seed!(42)\nconst CHAIN_LENGTH = 5000\nconst BURNIN = 1000\n\n# === Data Preparation ===\nprintln(\"Loading data...\")\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\npheno_df = CSV.read(pheno_path, DataFrame)\nprintln(\"  Individuals: \", nrow(pheno_df))\n\n# Create omics file\nomics_cols = vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])\nomics_df = pheno_df[:, omics_cols]\nCSV.write(\"omics.csv\", omics_df; missingstring=\"NA\")\n\n# Create trait file\ntrait_df = pheno_df[:, [:ID, :trait1]]\nCSV.write(\"traits.csv\", trait_df; missingstring=\"NA\")\n\n# === Define Model ===\nlayers = [\n    Layer(layer_name=\"geno\", data_path=[geno_path]),\n    Layer(layer_name=\"omics\", data_path=\"omics.csv\", missing_value=\"NA\"),\n    Layer(layer_name=\"pheno\", data_path=\"traits.csv\", missing_value=\"NA\")\n]\n\nequations = [\n    Equation(\n        from_layer_name=\"geno\", \n        to_layer_name=\"omics\",\n        equation=\"omics = intercept + geno\",\n        omics_name=[\"omic$i\" for i in 1:10],\n        method=\"BayesC\"\n    ),\n    Equation(\n        from_layer_name=\"omics\", \n        to_layer_name=\"pheno\",\n        equation=\"pheno = intercept + omics\",\n        phenotype_name=[\"trait1\"],\n        method=\"BayesC\",\n        activation_function=\"linear\"\n    )\n]\n\n# === Run MCMC ===\nprintln(\"Running MCMC (chain_length=$CHAIN_LENGTH, burnin=$BURNIN)...\")\nresults = runNNMM(layers, equations; \n                  chain_length=CHAIN_LENGTH, \n                  burnin=BURNIN,\n                  output_folder=\"results\")\n\n# === Results ===\nebv = results[\"EBV_NonLinear\"]\nprintln(\"\\nAnalysis complete!\")\nprintln(\"EBV saved in results folder.\")\nprintln(\"Mean EBV: \", round(mean(Float64.(ebv.EBV)), digits=4))\nprintln(\"Std EBV:  \", round(std(Float64.(ebv.EBV)), digits=4))\n\n# === Accuracy (if true breeding values available) ===\nif hasproperty(pheno_df, :genetic_total)\n    # Convert ID types for joining\n    ebv.ID = string.(ebv.ID)\n    pheno_df.ID = string.(pheno_df.ID)\n    merged = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\n    accuracy = cor(Float64.(merged.EBV), merged.genetic_total)\n    println(\"Accuracy (cor with true BV): \", round(accuracy, digits=4))\nend\n\n# Cleanup temp files\nrm(\"omics.csv\", force=true)\nrm(\"traits.csv\", force=true)","category":"section"},{"location":"manual/tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"Different activation functions: Try activation_function=\"sigmoid\" or \"tanh\" for nonlinear relationships\nDifferent Bayesian methods: Try method=\"BayesA\", \"BayesB\", \"BayesL\", or \"RR-BLUP\"\nAdd pedigree: Include random effects with pedigree relationships\nMulti-omics: Add more omics features in omics_name\nPartial-connected networks: See Part 4","category":"section"},{"location":"manual/tutorial/#Troubleshooting","page":"Tutorial","title":"Troubleshooting","text":"","category":"section"},{"location":"manual/tutorial/#Common-Issues","page":"Tutorial","title":"Common Issues","text":"\"There is data already stored in layer X\": Re-run the layers = [...] definition to reset.\n\"omicsname or phenotypename must be provided\": Ensure the first equation has omics_name and the second has phenotype_name.\nFolder already exists: NNMM auto-increments folder names (e.g., nnmm_results1, nnmm_results2).\nMemory issues: Use double_precision=false (default) for large datasets.\n\nSee the NNMM Examples for more advanced use cases.","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Part-6:-NNMM-as-Traditional-Genomic-Prediction","page":"Part 6. Traditional genomic prediction","title":"Part 6: NNMM as Traditional Genomic Prediction","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Overview","page":"Part 6. Traditional genomic prediction","title":"Overview","text":"NNMM is a general framework that encompasses traditional genomic prediction models as special cases. By configuring the network architecture appropriately, you can use NNMM to perform standard single-trait BayesC (and other Bayesian alphabet methods).\n\nThis demonstrates that NNMM generalizes traditional genomic prediction rather than replacing it.","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#The-Key-Insight","page":"Part 6. Traditional genomic prediction","title":"The Key Insight","text":"Traditional genomic prediction models like BayesC can be expressed as a special case of NNMM by:\n\nUsing a completely missing middle layer - Latent nodes will be sampled based on genotype information\nUsing a linear activation function - This ensures the relationship between the latent layer and phenotype is linear\n\n┌─────────────┐     ┌─────────────────┐     ┌─────────────┐\n│  Genotypes  │ ──► │  Latent Nodes   │ ──► │ Phenotype   │\n│   (SNPs)    │     │ (100% missing)  │     │    (y)      │\n└─────────────┘     └─────────────────┘     └─────────────┘\n                    Sampled via BayesC       Linear activation\n\nThis is mathematically equivalent to the traditional model:\n\ny = Xbeta + Zalpha + e\n\nwhere alpha are marker effects sampled using BayesC.\n\nimportant: Data Requirements\nGenotype and phenotype files must have matching individual IDs. This example uses the  simulated_omics_data dataset which has 3534 aligned individuals.","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Example:-Single-Trait-BayesC-via-NNMM","page":"Part 6. Traditional genomic prediction","title":"Example: Single-Trait BayesC via NNMM","text":"using NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(42)\n\n# Step 1: Load data (using simulated data with aligned individuals)\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Step 2: Create middle layer with completely missing latent nodes\n# Use at least 2 latent nodes for matrix operations in HMC\nn_individuals = nrow(pheno_df)\nlatent_df = DataFrame(\n    ID = pheno_df.ID,\n    latent1 = fill(missing, n_individuals),\n    latent2 = fill(missing, n_individuals)\n)\nlatent_file = \"latent_bayesc.csv\"\nCSV.write(latent_file, latent_df; missingstring=\"NA\")\n\n# Step 3: Create phenotype file\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_file = \"trait_bayesc.csv\"\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\n# Step 4: Define 3-layer network\nlayers = [\n    Layer(layer_name = \"geno\", data_path = [geno_path]),\n    Layer(layer_name = \"latent\", data_path = latent_file, missing_value = \"NA\"),\n    Layer(layer_name = \"phenotypes\", data_path = trait_file, missing_value = \"NA\")\n]\n\n# Step 5: Define equations with LINEAR activation\nequations = [\n    # Genotypes → Latent (marker regression with BayesC)\n    Equation(\n        from_layer_name = \"geno\",\n        to_layer_name = \"latent\",\n        equation = \"latent = intercept + geno\",\n        omics_name = [\"latent1\", \"latent2\"],\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    # Latent → Phenotype (LINEAR activation = standard regression)\n    Equation(\n        from_layer_name = \"latent\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + latent\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"linear\"  # Key: linear activation\n    )\n]\n\n# Step 6: Run analysis\nresult = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    output_folder = \"nnmm_bayesc_results\"\n)\n\n# Step 7: Get results\nebv = result[\"EBV_NonLinear\"]\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\n\nprintln(\"EBV mean: \", round(mean(Float64.(ebv.EBV)), digits=4))\nprintln(\"EBV std:  \", round(std(Float64.(ebv.EBV)), digits=4))\n\n# Check accuracy with true breeding values\nmerged = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\naccuracy = cor(Float64.(merged.EBV), merged.genetic_total)\nprintln(\"Accuracy: \", round(accuracy, digits=4))\n\n# Cleanup\nrm(latent_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Current-Limitations","page":"Part 6. Traditional genomic prediction","title":"Current Limitations","text":"warning: Multi-Trait Analysis\nMultiple phenotypes in the output layer (Layer 3) are not yet fully supported in the current NNMM implementation. Multi-trait genomic prediction will be supported in a future release.","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Comparison:-Direct-BayesC-vs-NNMM-as-BayesC","page":"Part 6. Traditional genomic prediction","title":"Comparison: Direct BayesC vs NNMM as BayesC","text":"Aspect Traditional BayesC NNMM as BayesC\nModel equation y = intercept + geno 3-layer network with missing middle\nMarker effects Directly estimated Estimated via latent layer\nFlexibility Fixed model Can add intermediate omics later\nResults EBV, marker effects EBV, marker effects\nComplexity Simpler Slightly more setup","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Why-Use-NNMM-for-Traditional-Analysis?","page":"Part 6. Traditional genomic prediction","title":"Why Use NNMM for Traditional Analysis?","text":"Unified framework: Same code structure for simple and complex models\nEasy extension: Add observed omics data to the middle layer when available\nGradual complexity: Start with traditional model, add neural network components as needed\nFuture-proof: As more omics data becomes available, simply fill in the missing values","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Other-Bayesian-Methods","page":"Part 6. Traditional genomic prediction","title":"Other Bayesian Methods","text":"You can use any Bayesian alphabet method by changing the method parameter:\n\n# BayesA - marker-specific variances, all markers included\nEquation(..., method=\"BayesA\")\n\n# BayesB - marker-specific variances, subset of markers included\nEquation(..., method=\"BayesB\", estimatePi=true)\n\n# BayesC - common variance, subset of markers included (default)\nEquation(..., method=\"BayesC\", estimatePi=true)\n\n# BayesL - Bayesian LASSO\nEquation(..., method=\"BayesL\")\n\n# RR-BLUP - Ridge Regression BLUP (all markers, common variance)\nEquation(..., method=\"RR-BLUP\")\n\n# GBLUP - Genomic BLUP (only for Layer 1→2)\n# Note: GBLUP is only supported for the genotype→omics equation\nEquation(..., method=\"GBLUP\")  # Layer 1→2 only","category":"section"},{"location":"nnmm/Part6_TraditionalGenomicPrediction/#Summary","page":"Part 6. Traditional genomic prediction","title":"Summary","text":"NNMM provides a superset of traditional genomic prediction methods:\n\nModel Type NNMM Configuration\nTraditional BayesC Missing middle layer + linear activation\nNNMM with omics Observed intermediate traits in middle layer\nFull neural network Nonlinear activation function\n\nThis design allows researchers to start with familiar methods and gradually incorporate more complex models as data and understanding grow.","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Part-3:-NNMM-with-Intermediate-Omics-Features","page":"Part 3. NNMM with intermediate omics","title":"Part 3: NNMM with Intermediate Omics Features","text":"note: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API.","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Model-Architecture","page":"Part 3. NNMM with intermediate omics","title":"Model Architecture","text":"When you have observed intermediate omics data (e.g., gene expression, metabolomics), NNMM can incorporate them in the middle layer:\n\nGenotypes → (Complete/Incomplete) Intermediate Omics → Phenotypes\n (Layer 1)              (Layer 2)                       (Layer 3)\n\ntip: Key Points\nOmics feature names are specified in the omics_name parameter of the first Equation\nMissing omics values are allowed and will be sampled via HMC\nTesting individuals (without phenotypes) can still contribute omics data to improve the genotype→omics model","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Example:-Fully-Connected-Network-with-Observed-Omics","page":"Part 3. NNMM with intermediate omics","title":"Example: Fully-Connected Network with Observed Omics","text":"This example demonstrates:\n\nActivation function: sigmoid (other options: \"tanh\", \"relu\", \"leakyrelu\", \"linear\")\nNumber of omics features: 10\nBayesian model: BayesC for marker effects\nMissing omics handling: Hamiltonian Monte Carlo\n\n(Image: )\n\n# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Load simulated dataset\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\n# Read data\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Step 3: Prepare omics file (Layer 2)\n# Select ID and 10 omics features\nomics_cols = vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])\nomics_df = pheno_df[:, omics_cols]\nomics_names = names(omics_df)[2:end]  # [\"omic1\", \"omic2\", ..., \"omic10\"]\n\nomics_file = \"omics_data.csv\"\nCSV.write(omics_file, omics_df; missingstring=\"NA\")\n\n# Step 4: Prepare phenotype file (Layer 3)\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_file = \"phenotypes_data.csv\"\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\n# Step 5: Define layers\nlayers = [\n    # Layer 1: Genotypes\n    Layer(\n        layer_name = \"genotypes\",\n        data_path = [geno_path]\n    ),\n    # Layer 2: Omics (with observed values)\n    Layer(\n        layer_name = \"omics\",\n        data_path = omics_file,\n        missing_value = \"NA\"\n    ),\n    # Layer 3: Phenotypes\n    Layer(\n        layer_name = \"phenotypes\",\n        data_path = trait_file,\n        missing_value = \"NA\"\n    )\n]\n\n# Step 6: Define equations\nequations = [\n    # Genotypes → Omics (BayesC)\n    Equation(\n        from_layer_name = \"genotypes\",\n        to_layer_name = \"omics\",\n        equation = \"omics = intercept + genotypes\",\n        omics_name = omics_names,  # Names of omics columns\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    # Omics → Phenotypes (sigmoid activation)\n    Equation(\n        from_layer_name = \"omics\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + omics\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"sigmoid\"\n    )\n]\n\n# Step 7: Run analysis\nout = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    printout_frequency = 2000,  # Print every 2000 iterations\n    output_folder = \"nnmm_omics_results\"\n)\n\n# Step 8: Check accuracy\nebv = out[\"EBV_NonLinear\"]\n\n# Convert ID types for joining (EBV IDs may be of type Any)\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\n\n# If true breeding values available:\nif hasproperty(pheno_df, :genetic_total)\n    results = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\n    accuracy = cor(Float64.(results.EBV), results.genetic_total)\n    println(\"Prediction accuracy: \", round(accuracy, digits=4))\nend\n\n# Cleanup\nrm(omics_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Including-Residual-Polygenic-Effects","page":"Part 3. NNMM with intermediate omics","title":"Including Residual Polygenic Effects","text":"To include a residual polygenic component (genetic effects not mediated by omics), add an extra latent node to the middle layer:\n\n(Image: )","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Example:-Network-with-Residual-Polygenic-Effect","page":"Part 3. NNMM with intermediate omics","title":"Example: Network with Residual Polygenic Effect","text":"# Step 1: Load packages\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames\nusing CSV\nusing Statistics\nusing Random\n\nRandom.seed!(123)\n\n# Step 2: Load data\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Step 3: Create omics file WITH an extra \"residual\" column (all missing)\nomics_cols = vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])\nomics_df = pheno_df[:, omics_cols]\n\n# Add residual column (all missing - will be sampled)\nomics_df[!, :residual] = fill(missing, nrow(omics_df))\n\nomics_names = names(omics_df)[2:end]  # [\"omic1\", ..., \"omic10\", \"residual\"]\n\nomics_file = \"omics_with_residual.csv\"\nCSV.write(omics_file, omics_df; missingstring=\"NA\")\n\n# Step 4: Create phenotype file\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_file = \"phenotypes_data.csv\"\nCSV.write(trait_file, trait_df; missingstring=\"NA\")\n\n# Step 5: Define layers\nlayers = [\n    Layer(layer_name = \"genotypes\", data_path = [geno_path]),\n    Layer(layer_name = \"omics\", data_path = omics_file, missing_value = \"NA\"),\n    Layer(layer_name = \"phenotypes\", data_path = trait_file, missing_value = \"NA\")\n]\n\n# Step 6: Define equations (11 features: 10 omics + 1 residual)\nequations = [\n    Equation(\n        from_layer_name = \"genotypes\",\n        to_layer_name = \"omics\",\n        equation = \"omics = intercept + genotypes\",\n        omics_name = omics_names,  # Includes \"residual\"\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    Equation(\n        from_layer_name = \"omics\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + omics\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"sigmoid\"\n    )\n]\n\n# Step 7: Run analysis\nout = runNNMM(layers, equations;\n    chain_length = 5000,\n    burnin = 1000,\n    output_folder = \"nnmm_residual_results\"\n)\n\n# Step 8: Check accuracy\nebv = out[\"EBV_NonLinear\"]\n\n# Convert ID types for joining\nebv.ID = string.(ebv.ID)\npheno_df.ID = string.(pheno_df.ID)\n\nif hasproperty(pheno_df, :genetic_total)\n    results = innerjoin(ebv, pheno_df[:, [:ID, :genetic_total]], on=:ID)\n    accuracy = cor(Float64.(results.EBV), results.genetic_total)\n    println(\"Prediction accuracy: \", round(accuracy, digits=4))\nend\n\n# Cleanup\nrm(omics_file, force=true)\nrm(trait_file, force=true)","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Handling-Missing-Omics-Data","page":"Part 3. NNMM with intermediate omics","title":"Handling Missing Omics Data","text":"NNMM automatically handles missing omics values in the training set. Missing values are sampled using HMC based on:\n\nThe upstream genotype layer (marker effects)\nThe downstream phenotype layer (via backpropagation)","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Setting-Missing-Values-Manually","page":"Part 3. NNMM with intermediate omics","title":"Setting Missing Values Manually","text":"# Convert column type to allow missing values\nomics_df[!, :omic1] = convert(Vector{Union{Missing, Float64}}, omics_df[!, :omic1])\n\n# Set specific values to missing\nomics_df[10:15, :omic1] .= missing  # Set rows 10-15 as missing for omic1\n\n# Set phenotypes for testing individuals as missing\npheno_df[!, :trait1] = convert(Vector{Union{Missing, Float64}}, pheno_df[!, :trait1])\npheno_df[90:100, :trait1] .= missing  # Testing individuals","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Output-Files","page":"Part 3. NNMM with intermediate omics","title":"Output Files","text":"The output files are the same as described in Part 2, with omics names replacing latent node names.","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Tips","page":"Part 3. NNMM with intermediate omics","title":"Tips","text":"Many omics features: For large numbers of omics (>100), set printout_frequency to a large value to reduce console output.\nPre-processing: Center and scale omics data before running NNMM for better convergence.\nTesting individuals: Include individuals without phenotypes if they have omics data - this improves the genotype→omics model.\nResidual effects: Add a completely missing \"residual\" column to capture genetic variance not explained by omics.","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: NNMM)","category":"section"},{"location":"#NNMM.jl-Neural-Network-Mixed-Models","page":"Home","title":"NNMM.jl - Neural Network Mixed Models","text":"NNMM.jl is a Julia package for Mixed Effect Neural Networks that extend traditional linear mixed models to multilayer neural networks for genomic prediction and genome-wide association studies.\n\nnote: Version Compatibility\nThis documentation reflects NNMM.jl v0.3+ using the Layer/Equation/runNNMM API. For earlier versions using build_model/runMCMC, see the Legacy API section.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Generalizes Traditional Methods: Traditional BayesC and other Bayesian alphabet methods are special cases of NNMM\nNeural Network Architecture: Extend linear mixed models to multilayer neural networks\nIntermediate Omics Integration: Incorporate known intermediate omics features (e.g., gene expression) in the middle layer\nFlexible Missing Data Handling: Allow any patterns of missing data in intermediate layers\nBayesian Framework: Full Bayesian inference using MCMC and Hamiltonian Monte Carlo\nMulti-threaded Parallelism: Efficient parallel computing for large-scale analyses","category":"section"},{"location":"#Network-Architecture","page":"Home","title":"Network Architecture","text":"NNMM models relationships between:\n\nInput Layer: Genotypes (SNP markers)\nMiddle Layer: Intermediate traits (e.g., gene expression, metabolomics)\nOutput Layer: Phenotypes\n\nThe package supports:\n\nFully-connected neural networks\nPartial-connected neural networks\nUser-defined nonlinear activation functions","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"NNMM\")\n\nOr for the latest development version:\n\nPkg.add(url=\"https://github.com/reworkhow/NNMM.jl\")\n\nRequirements: Julia 1.9 or later.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"This example uses built-in simulated data to demonstrate the NNMM workflow:\n\nusing NNMM\nusing NNMM.Datasets\nusing DataFrames, CSV\nusing Statistics\nusing Random\n\n# Set seed for reproducibility\nRandom.seed!(42)\n\n# Load built-in simulated dataset\ngeno_path = Datasets.dataset(\"genotypes_1000snps.txt\", dataset_name=\"simulated_omics_data\")\npheno_path = Datasets.dataset(\"phenotypes_sim.txt\", dataset_name=\"simulated_omics_data\")\n\n# Read phenotype file and create separate omics/trait files\npheno_df = CSV.read(pheno_path, DataFrame)\n\n# Create omics file (10 omics features)\nomics_df = pheno_df[:, vcat(:ID, [Symbol(\"omic$i\") for i in 1:10])]\nomics_path = \"omics_temp.csv\"\nCSV.write(omics_path, omics_df; missingstring=\"NA\")\n\n# Create trait file\ntrait_df = pheno_df[:, [:ID, :trait1]]\ntrait_path = \"trait_temp.csv\"\nCSV.write(trait_path, trait_df; missingstring=\"NA\")\n\n# Define network layers (3-layer architecture)\nlayers = [\n    # Layer 1: Genotypes (input layer)\n    Layer(layer_name=\"geno\", data_path=[geno_path]),\n    # Layer 2: Omics (hidden/intermediate layer)  \n    Layer(layer_name=\"omics\", data_path=omics_path, missing_value=\"NA\"),\n    # Layer 3: Phenotypes (output layer)\n    Layer(layer_name=\"phenotypes\", data_path=trait_path, missing_value=\"NA\")\n]\n\n# Define equations connecting layers\nequations = [\n    # Equation 1: Genotypes → Omics\n    Equation(\n        from_layer_name = \"geno\",\n        to_layer_name = \"omics\",\n        equation = \"omics = intercept + geno\",\n        omics_name = [\"omic$i\" for i in 1:10],\n        method = \"BayesC\",\n        estimatePi = true\n    ),\n    # Equation 2: Omics → Phenotypes  \n    Equation(\n        from_layer_name = \"omics\",\n        to_layer_name = \"phenotypes\",\n        equation = \"phenotypes = intercept + omics\",\n        phenotype_name = [\"trait1\"],\n        method = \"BayesC\",\n        activation_function = \"linear\"  # or \"sigmoid\", \"tanh\", \"relu\"\n    )\n]\n\n# Run NNMM analysis\nresults = runNNMM(layers, equations;\n    chain_length = 5000,        # Total MCMC iterations\n    burnin = 1000,              # Burn-in iterations to discard\n    output_folder = \"nnmm_results\"\n)\n\n# Access results\nebv = results[\"EBV_NonLinear\"]  # Estimated breeding values\nprintln(\"Mean EBV: \", mean(Float64.(ebv.EBV)))\n\n# Cleanup temporary files\nrm(omics_path, force=true)\nrm(trait_path, force=true)","category":"section"},{"location":"#API-Summary-Table","page":"Home","title":"API Summary Table","text":"Example Required Packages Entry Function(s) What It Demonstrates\nQuick Start NNMM, DataFrames, CSV Layer, Equation, runNNMM Basic 3-layer NNMM with BayesC\nTutorial NNMM, DataFrames, CSV Layer, Equation, runNNMM, GWAS Complete workflow with GWAS\nPart2: NNMM NNMM, DataFrames, CSV Layer, Equation, runNNMM Fully-connected NNMM\nPart3: Omics NNMM, DataFrames, CSV Layer, Equation, runNNMM NNMM with observed omics\nPart4: Partial NNMM, DataFrames, CSV Layer, Equation, runNNMM Partial-connected networks\nPart5: Custom NNMM, DataFrames, CSV Layer, Equation, runNNMM User-defined activation functions\nPart6: Traditional NNMM, DataFrames, CSV Layer, Equation, runNNMM Traditional BayesC as NNMM","category":"section"},{"location":"#Supporting-and-Citing","page":"Home","title":"Supporting and Citing","text":"If you use NNMM.jl for your research, please cite:\n\nZhao, T., Zeng, J., & Cheng, H. (2022). Extend mixed models to multilayer neural networks for genomic prediction including intermediate omics data. GENETICS. https://doi.org/10.1093/genetics/iyac034\n\nZhao, T., Fernando, R., & Cheng, H. (2021). Interpretable artificial neural networks incorporating Bayesian alphabet models for genome-wide prediction and association studies. G3 Genes|Genomes|Genetics. https://doi.org/10.1093/g3journal/jkab228\n\nPlease star the repository here to help demonstrate community involvement.","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Open an issue on GitHub\nContact: <qtlcheng@ucdavis.edu>","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#NNMM-Tutorials","page":"Home","title":"NNMM Tutorials","text":"Pages = [\n  \"nnmm/Part1_introduction.md\",\n  \"nnmm/Part2_NNMM.md\",\n  \"nnmm/Part3_NNMMwithIntermediateOmics.md\",\n  \"nnmm/Part4_PartialConnectedNeuralNetwork.md\",\n  \"nnmm/Part5_UserDefinedNonlinearFunction.md\",\n  \"nnmm/Part6_TraditionalGenomicPrediction.md\",\n]\nDepth = 2","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"Pages = [\n  \"manual/getstarted.md\",\n  \"manual/tutorial.md\",\n  \"manual/public.md\",\n]\nDepth = 2","category":"section"},{"location":"#Legacy-API","page":"Home","title":"Legacy API","text":"warning: Deprecated API\nThe build_model / get_genotypes / runMCMC API from earlier versions is deprecated. Please use the new Layer / Equation / runNNMM API shown above.Legacy example (do not use for new code):# OLD API - DEPRECATED\ngenotypes = get_genotypes(\"genotypes.csv\", separator=',', method=\"BayesC\")\nmodel = build_model(\"y = intercept + genotypes\", num_hidden_nodes=3, nonlinear_function=\"tanh\")\nout = runMCMC(model, phenotypes, chain_length=5000)","category":"section"}]
}
